#!/usr/bin/env node

const fs = require('node:fs/promises'),
  path = require('node:path'),
  math = require('mathjs'),
  IccMaxDOM = require('../lib/iccmax-dom'),
  fp = require('../lib/fp'),
  { decode_ndin } = require('../lib/icc-private-tags'),
  {
    xyzChromaticity,
    chromaticAdaptBradford,
    createChromaticAdaptionBradford,
    createLut,
    createMacDefaultLut
  } = require('../lib/display-icc'),
  DISPLAY_PCS_D50_WHITE = [0.964202880859, 1.0, 0.824905395508],
  CIE_D50_WHITE = [0.96422, 1, 0.82521],
  // round S15FixedNumber
  r = (v) => fp.fromS15F16Int32(fp.toS15F16Int32(v))

async function getChroma(file) {
  const icc_xml_file = path.join(__dirname, '..', 'data', file),
    icc = await IccMaxDOM.fromXmlFile(icc_xml_file),
    chroma = icc.selectDisplayChromaticity(),
    ndin = decode_ndin(icc.selectPrivateTagData('ndin'), true),
    native_chroma = r(xyzChromaticity(ndin)),
    pcs_w = icc.selectHeader().PCSIlluminant

  return { chroma, ndin, native_chroma, pcs_w }
}

/**
 * An attempt to understand what kind of calculations Display Calibrator Assistant is performing
 */
async function main() {
  const src = await getChroma('aw3225qf_macos_icc.xml'),
    // generated by Coloro Calibrator Assistant.app
    target = await getChroma('aw3225qf_d50_macos_icc.xml')
  //
  // - src mediaWhitePoint is display's native white point, Generally it is close to D65
  // - src colorant is native-value adapted from native-white-point to PCSIlluminant(D50)
  //
  // - target mediaWwhitePoint is near D50 white
  //   w: [ 0.961975097656, 1, 0.849639892578 ]
  //
  // - target rgb sum euals PCSIlluminant, not mediaWHitePoint
  //   rgbsum [ 0.964202880859, 1.0000000000009999, 0.824905395508 ]
  //
  console.log(
    'src',
    src,
    'target',
    target,
    'target rgb sum',
    math.add(target.chroma.r, target.chroma.g, target.chroma.b)
  )

  // trying inverse operation
  // rgb values are exact match, so just need to know how the white point close to D50 was calculated.
  //    taget w: [ 0.961975097656, 1, 0.849639892578 ]
  const sum_target_w = math.sum(target.chroma.w),
    corrected_native_xy_cordinates = {
      r: [src.ndin.r[0], src.ndin.r[1]],
      g: [src.ndin.g[0], src.ndin.g[1]],
      b: [src.ndin.b[0], src.ndin.b[1]],
      w: fp.toS15F16Int32([target.chroma.w[0] / sum_target_w, target.chroma.w[1] / sum_target_w])
    },
    // xy cordicatess to xyz chroma
    corrected_native_chroma = xyzChromaticity(corrected_native_xy_cordinates),
    caluculated_chroma = chromaticAdaptBradford(corrected_native_chroma, DISPLAY_PCS_D50_WHITE)

  console.log('target chroma', target.chroma, 'calculated chroma', r(caluculated_chroma))

  // ......
  const native_white = [0.949554443359, 1, 1.089019775391],
    target_d50_white = [0.961975097656, 1, 0.849639892578],
    native_color_temp = xyz2colorTemp(native_white),
    xyz_native_color_temp_minus_1500 = colorTemp2xyz(native_color_temp - 1549)
  console.log('D6500', r(colorTemp2xyz(6500)), colorTemp2xy(6500))
  console.log('D6504', r(colorTemp2xyz(6504)), colorTemp2xy(6504))
  console.log('D5000', r(colorTemp2xyz(5000)), colorTemp2xy(5000))
  console.log('PCS White', DISPLAY_PCS_D50_WHITE, xyz2xy(DISPLAY_PCS_D50_WHITE))
  console.log('target white', target_d50_white, 'calculated', r(xyz_native_color_temp_minus_1500))
}

function xy2xyz(xy) {
  const x = xy[0],
    y = xy[1]
  return [x / y, 1, (1 - x - y) / y]
}
function xyz2xy(xyz) {
  const sum = math.sum(xyz)
  return [xyz[0] / sum, (y = xyz[0] / sum)]
}

function colorTemp2xyz(t) {
  return xy2xyz(colorTemp2xy(t))
}

function colorTemp2xy(t) {
  const x =
      (-4.607 * 10 ** 9) / t ** 3 +
      (2.9678 * 10 ** 6) / t ** 2 +
      (0.09911 * 10 ** 3) / t +
      0.244063,
    y = -3.0 * x ** 2 + 2.87 * x - 0.275
  return [x, y]
}

// McCamy's Formula
function xyz2colorTemp(xyz) {
  return xy2colorTemp(xyz2xy(xyz))
}

function xy2colorTemp(xy) {
  const x = xy[0],
    y = xy[1],
    n = (x - 0.332) / (y - 0.1858)
  return -449 * n ** 3 + 3525 * n ** 2 - 6823.3 * n + 5520.33
}

main()
  .catch((err) => {
    console.error(err)
    process.exit(1)
  })
  .then(() => {})
