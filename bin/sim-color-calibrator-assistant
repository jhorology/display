#!/usr/bin/env node

const fs = require('node:fs/promises'),
  path = require('node:path'),
  math = require('mathjs'),
  deapEqual = require('deep-equal'),
  IccMaxDOM = require('../lib/iccmax-dom'),
  fp = require('../lib/fp'),
  { decode_ndin } = require('../lib/icc-private-tags'),
  {
    xyzChromaticity,
    chromaticAdaptBradford,
    createChromaticAdaptionBradford,
    createLut,
    createMacDefaultLut
  } = require('../lib/display-icc'),
  DISPLAY_PCS_D50_WHITE = [0.964202880859, 1.0, 0.824905395508],
  CIE_D50_WHITE = [0.96422, 1, 0.82521],
  // round S15FixedNumber
  r = (v) => fp.fromS15F16Int32(fp.toS15F16Int32(v))

async function getChroma(file) {
  const icc_xml_file = path.join(__dirname, '..', 'data', file),
    icc = await IccMaxDOM.fromXmlFile(icc_xml_file),
    chroma = icc.selectDisplayChromaticity(),
    ndin = decode_ndin(icc.selectPrivateTagData('ndin'), true),
    native_chroma = r(xyzChromaticity(ndin)),
    pcs_w = icc.selectHeader().PCSIlluminant

  return { chroma, ndin, native_chroma, pcs_w }
}

function rgbEual(a, b) {
  return deapEqual({ r: a.r, g: a.g, b: a.b }, { r: b.r, g: b.g, b: b.b })
}

function subtractInt(a, b) {
  return math.subtract(fp.toS15F16Int32(a), fp.toS15F16Int32(b))
}

/**
 * An attempt to understand what kind of calculations Display Calibrator Assistant is performing
 */
async function test(t) {
  const src = await getChroma(t.src),
    // generated by Coloro Calibrator Assistant.app
    target = await getChroma(t.target)
  //
  // - src mediaWhitePoint is display's native white point, Generally it is close to D65
  // - src colorant is native-value adapted from native-white-point to PCSIlluminant(D50)
  //
  // - target mediaWwhitePoint is near D50 white
  //   w: [ 0.961975097656, 1, 0.849639892578 ]
  //
  // - target rgb sum equals PCSIlluminant, not mediaWHitePoint
  //   rgbsum [ 0.964202880859, 1.0000000000009999, 0.824905395508 ]
  //
  console.log('\ntest', t, '------------------->')
  console.log('target rgb sum', math.add(target.chroma.r, target.chroma.g, target.chroma.b))
  console.log('target PCSIlluminant', target.pcs_w)
  console.log('source PCSIlluminant', src.pcs_w)

  // trying inverse operation
  // rgb values are exact match, so just need to know how the mediaWHitePoint was calculated.
  const sum_target_w = math.sum(target.chroma.w),
    corrected_native_xy_cordinates = {
      r: fp.fromS15F16Int32([src.ndin.r[0], src.ndin.r[1]]),
      g: fp.fromS15F16Int32([src.ndin.g[0], src.ndin.g[1]]),
      b: fp.fromS15F16Int32([src.ndin.b[0], src.ndin.b[1]]),
      w: [target.chroma.w[0] / sum_target_w, target.chroma.w[1] / sum_target_w]
    },
    // xy cordicatess to xyz chroma
    corrected_native_chroma = xyzChromaticity(corrected_native_xy_cordinates, false),
    calculated_chroma = chromaticAdaptBradford(corrected_native_chroma, DISPLAY_PCS_D50_WHITE),
    printXYZ = (n, t, c) => {
      console.log(
        n,
        'target',
        t,
        'calc',
        c,
        'diff',
        math.subtract(fp.toS15F16Int32(c), fp.toS15F16Int32(t))
      )
    }

  printXYZ('mediaWhitePoint', target.chroma.w, corrected_native_chroma.w)
  printXYZ('red colorant', target.chroma.r, calculated_chroma.r)
  printXYZ('green colorant', target.chroma.g, calculated_chroma.g)
  printXYZ('blue colorant', target.chroma.b, calculated_chroma.b)
  //
  // Try convtering the white point keeping the UV deviation
  //
  const native_w_xyz = src.chroma.w,
    native_w_xy = xyz2xy(native_w_xyz),
    native_w_uv = xy2uv(native_w_xy),
    native_ct = xy2cct(native_w_xy),
    native_w_xyp = ct2xy(native_ct),
    native_w_uvp = xy2uv(native_w_xyp),
    native_w_uv_offset = math.subtract(native_w_uv, native_w_uvp),
    native_w_duv = duv(native_w_uv, native_w_uvp),
    target_ct = t.k,
    target_w_xyp = ct2xy(target_ct),
    target_w_uvp = xy2uv(target_w_xyp),
    // Simple approximation formula
    target_w_uv = math.add(target_w_uvp, native_w_uv_offset),
    target_w_xy = uv2xy(target_w_uv),
    target_w_xyz = xy2xyz(target_w_xy)
  console.log(``)
  console.log(`fn([${src.chroma.w}], ${t.k}) = [${target.chroma.w}]`)
  console.log(``)
  console.log('native white xyz', native_w_xyz)
  console.log('native white xy', native_w_xy)
  console.log('native white uv', native_w_uv)
  console.log('native CCT', native_ct)
  console.log('native white reference xy', native_w_xyp)
  console.log('native white reference uv', native_w_uvp)
  console.log('native white uv offset', native_w_uv_offset)
  console.log('native white uv deviation', native_w_duv)
  console.log('target reference CT', target_ct)
  console.log('target white reference xy', target_w_xyp)
  console.log('target white reference uv', target_w_uvp)
  console.log('target white uv (added native offset)', target_w_uv)
  console.log('target white xy', target_w_xy)
  console.log('target white xyz', target_w_xyz)
  console.log(
    'diff',
    math.subtract(fp.toS15F16Int32(target_w_xyz), fp.toS15F16Int32(target.chroma.w))
  )
}

function xy2xyz(xy) {
  const x = xy[0],
    y = xy[1]
  return [x / y, 1, (1 - x - y) / y]
}

function xyz2xy(xyz) {
  const sum = math.sum(xyz)
  return [xyz[0] / sum, xyz[1] / sum]
}

function ct2xyz(t) {
  return xy2xyz(ct2xy(t))
}

/**
 * color temperature to xy on blackbody locus
 * formula of Kang et al.
 */
function ct2xy(t) {
  // kang et al. formula 1667K - 2222k - 4000K - 25000K
  const a = t < 4000 ? -0.2661239 : -3.0258469,
    b = t < 4000 ? -0.2343589 : 2.1070379,
    c = t < 4000 ? 0.8776956 : 0.2226347,
    d = t < 4000 ? 0.17991 : 0.24039,
    e = t < 2222 ? -1.1063814 : t < 4000 ? -0.9549476 : 3.081758,
    f = t < 2222 ? -1.3481102 : t < 4000 ? -1.37418593 : -5.8733867,
    g = t < 2222 ? 2.18555832 : t < 4000 ? 2.09137015 : 3.75112997,
    h = t < 2222 ? -0.20219683 : t < 4000 ? -0.16748867 : -0.37001483,
    x = (a * 10 ** 9) / t ** 3 + (b * 10 ** 6) / t ** 2 + (c * 10 ** 3) / t + d,
    y = e * x ** 3 + f * x ** 2 + g * x + h
  return [x, y]
}

/**
 * xy to CIE1976 UCS luv
 */
function xy2uv(xy) {
  const x = xy[0],
    y = xy[1],
    divider = -2 * x + 12 * y + 3,
    u = (4 * x) / divider,
    v = (9 * y) / divider
  return [u, v]
}

function uv2xy(uv) {
  const u = uv[0],
    v = uv[1],
    divider = 6 * u - 16 * v + 12,
    x = (9 * u) / divider,
    y = (4 * v) / divider
  return [x, y]
}

function duv(src, reference) {
  const du = src[0] - reference[0],
    dv = src[1] - reference[1],
    duv = Math.sqrt(du ** 2 + dv ** 2)
  // TODO not always correct
  return dv < 0 ? -duv : duv
}

function xyz2cct(xyz) {
  return xy2cct(xyz2xy(xyz))
}

function xy2cct(xy) {
  const x = xy[0],
    y = xy[1],
    n = (x - 0.332) / (y - 0.1858)
  return -449 * n ** 3 + 3525 * n ** 2 - 6823.3 * n + 5520.33
}

async function main() {
  const tests = [
      // hint = native white point color temp indicated by Color Calibrator Assistant
      { k: 5000, src: 'aw3225qf_macos_icc.xml', target: 'aw3225qf_d50_macos_icc.xml', hint: 6509 },
      { k: 6500, src: 'aw3225qf_macos_icc.xml', target: 'aw3225qf_d65_macos_icc.xml', hint: 6509 },
      { k: 5000, src: 's3221qs_macos_icc.xml', target: 's3221qs_d50_macos_icc.xml', hint: 6479 },
      { k: 6500, src: 's3221qs_macos_icc.xml', target: 's3221qs_d65_macos_icc.xml', hint: 6479 }
    ],
    results = await Promise.all(tests.map(async (t) => await test(t)))
  console.log(JSON.stringify(results, null, 2))
}

main()
  .catch((err) => {
    console.error(err)
    process.exit(1)
  })
  .then(() => {})
